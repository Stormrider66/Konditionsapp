/**
 * POST /api/workouts/modify
 *
 * Assess current readiness and automatically modify planned workout
 */

import { NextRequest } from 'next/server';
import { z } from 'zod';
import {
  validateRequest,
  successResponse,
  handleApiError,
  requireAuth,
} from '@/lib/api/utils';
import { prisma } from '@/lib/prisma';
import {
  modifyWorkout,
  type ModifyWorkoutInput,
  type ModificationDecision,
  type WorkoutIntensity,
} from '@/lib/training-engine/workout-modifier';
import { MethodologyType } from '@/lib/training-engine/methodologies/types';

const requestSchema = z.object({
  workoutId: z.string(),
  athleteId: z.string(),
  currentReadiness: z
    .object({
      readinessScore: z.number().min(0).max(10).optional(),
      hrvPercentOfBaseline: z.number().optional(),
      rhrDeviationBpm: z.number().optional(),
      wellnessScore: z.number().min(1).max(10).optional(),
      sleepHours: z.number().min(0).max(16).optional(),
      musclesoreness: z.number().min(1).max(10).optional(),
      fatigue: z.number().min(1).max(10).optional(),
      acwrRatio: z.number().optional(),
    })
    .optional(),
  overrideDecision: z.enum(['PROCEED', 'REDUCE', 'EASY', 'REST']).optional(),
});

export async function POST(request: NextRequest) {
  try {
    const user = await requireAuth();

    const validation = await validateRequest(request, requestSchema);
    if (!validation.success) return validation.response;

    const { workoutId, athleteId, currentReadiness, overrideDecision } =
      validation.data;

    // Get workout details
    const workout = await prisma.workout.findUnique({
      where: { id: workoutId },
      include: {
        day: {
          include: {
            week: {
              include: {
                program: true
              }
            }
          }
        },
        segments: true,
      },
    });

    if (!workout) {
      return handleApiError(new Error('Workout not found'));
    }

    // Get athlete profile
    const athlete = await prisma.client.findUnique({
      where: { id: athleteId },
      include: {
        tests: {
          orderBy: { testDate: 'desc' },
          take: 1,
        },
      },
    });

    if (!athlete) {
      return handleApiError(new Error('Athlete not found'));
    }

    const readinessSnapshot = await resolveReadinessSnapshot(
      athleteId,
      currentReadiness,
    );

    const methodology = 'POLARIZED' as MethodologyType;

    const readinessScore = readinessSnapshot?.score ?? 7;
    const readinessComponents = buildReadinessComponents(readinessSnapshot);

    const coachOverride = overrideDecision
      ? {
          decision: mapOverrideDecision(overrideDecision),
          rationale: 'Coach override via API',
        }
      : undefined;

    const modification = modifyWorkout({
      readinessScore,
      readinessComponents,
      workoutIntensity: toWorkoutIntensity(workout.intensity),
      workoutDurationMinutes: workout.duration ?? undefined,
      workoutDistanceKm: workout.distance ?? undefined,
      workoutType: workout.type,
      methodology,
      athleteId,
      coachOverride,
    });

    const stored = await prisma.workoutModification.create({
      data: {
        workoutId: workout.id,
        decision: modification.decision,
        autoGenerated: !overrideDecision,
        plannedType: workout.type,
        plannedDuration: workout.duration ?? 0,
        plannedDistance: workout.distance ?? null,
        plannedIntensity: workout.intensity,
        plannedDetails: {
          description: workout.description,
          segments: workout.segments,
        },
        modifiedType: modification.modifiedWorkout?.type ?? null,
        modifiedDuration: modification.modifiedWorkout?.durationMinutes ?? null,
        modifiedDistance: modification.modifiedWorkout?.distanceKm ?? null,
        modifiedIntensity: modification.modifiedWorkout?.intensity ?? null,
        modifiedDetails: modification.modifiedWorkout ?? undefined,
        readinessScore: modification.readinessScore,
        factors: formatFactors(modification),
        reasoning: modification.rationale,
        methodology,
        acwr: readinessSnapshot?.acwrRatio ?? null,
      },
    });

    return successResponse({
      success: true,
      decision: modification.decision,
      modification: stored,
      recommendations: modification.recommendations,
      result: modification,
    });
  } catch (error) {
    return handleApiError(error);
  }
}

type ManualReadinessInput = NonNullable<
  z.infer<typeof requestSchema>['currentReadiness']
>

interface ResolvedReadinessSnapshot {
  score: number
  hrvPercent?: number
  hrvTrend?: string | null
  rhrDeviation?: number
  wellnessScore?: number
  fatigue?: number
  muscleSoreness?: number
  sleepHours?: number
  acwrRatio?: number
}

async function resolveReadinessSnapshot(
  athleteId: string,
  manual?: ManualReadinessInput
): Promise<ResolvedReadinessSnapshot | null> {
  if (manual) {
    const score =
      manual.readinessScore ?? manual.wellnessScore ?? manual.fatigue ?? 7;
    return {
      score,
      hrvPercent: manual.hrvPercentOfBaseline,
      rhrDeviation: manual.rhrDeviationBpm,
      wellnessScore: manual.wellnessScore,
      fatigue: manual.fatigue,
      muscleSoreness: manual.musclesoreness,
      sleepHours: manual.sleepHours,
      acwrRatio: manual.acwrRatio,
    };
  }

  const latest = await prisma.dailyMetrics.findFirst({
    where: { clientId: athleteId },
    orderBy: { date: 'desc' },
  });

  if (!latest) {
    return null;
  }

  return {
    score: latest.readinessScore ?? latest.wellnessScore ?? 7,
    hrvPercent: latest.hrvPercent ?? undefined,
    hrvTrend: latest.hrvTrend,
    rhrDeviation: latest.restingHRDev ?? undefined,
    wellnessScore: latest.wellnessScore ?? undefined,
    fatigue: latest.energyLevel ?? undefined,
    muscleSoreness: latest.muscleSoreness ?? undefined,
    sleepHours: latest.sleepHours ?? undefined,
  };
}

function buildReadinessComponents(
  snapshot: ResolvedReadinessSnapshot | null
): ModifyWorkoutInput['readinessComponents'] {
  if (!snapshot) return undefined;

  const components: ModifyWorkoutInput['readinessComponents'] = {};

  if (snapshot.hrvPercent !== undefined) {
    components.hrv = {
      percentOfBaseline: snapshot.hrvPercent,
      consecutiveDecliningDays: snapshot.hrvTrend === 'DECLINING' ? 3 : 0,
    };
  }

  if (snapshot.rhrDeviation !== undefined) {
    components.rhr = {
      deviationBpm: snapshot.rhrDeviation,
      consecutiveElevatedDays: Math.abs(snapshot.rhrDeviation) > 5 ? 3 : 0,
    };
  }

  if (
    snapshot.wellnessScore !== undefined ||
    snapshot.fatigue !== undefined ||
    snapshot.muscleSoreness !== undefined
  ) {
    components.wellness = {
      fatigue: snapshot.fatigue ?? 5,
      muscleSoreness: snapshot.muscleSoreness ?? 5,
      stress: 5,
      mood: 5,
    };
  }

  if (snapshot.sleepHours !== undefined) {
    components.sleep = {
      duration: snapshot.sleepHours,
      quality: snapshot.sleepHours >= 7 ? 8 : 5,
    };
  }

  return Object.keys(components).length ? components : undefined;
}

function mapOverrideDecision(
  decision: 'PROCEED' | 'REDUCE' | 'EASY' | 'REST'
): ModificationDecision {
  switch (decision) {
    case 'PROCEED':
      return 'PROCEED';
    case 'REDUCE':
      return 'REDUCE_BOTH';
    case 'EASY':
      return 'EASY_DAY';
    case 'REST':
      return 'REST';
  }
}

function toWorkoutIntensity(value?: string | null): WorkoutIntensity {
  const fallback: WorkoutIntensity = 'MODERATE';
  if (!value) return fallback;
  const allowed: WorkoutIntensity[] = [
    'RECOVERY',
    'EASY',
    'MODERATE',
    'THRESHOLD',
    'HARD',
    'VERY_HARD',
  ];
  return allowed.includes(value as WorkoutIntensity)
    ? (value as WorkoutIntensity)
    : fallback;
}

function formatFactors(modification: ReturnType<typeof modifyWorkout>) {
  if (!modification.factors) return [];
  return Object.entries(modification.factors).map(([factor, detail]) => ({
    factor,
    ...(detail || {}),
  }));
}

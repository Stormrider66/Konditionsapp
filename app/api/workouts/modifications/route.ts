/**
 * Workout Modifications API
 *
 * GET /api/workouts/modifications - Retrieve all auto-modified workouts
 *
 * Returns workouts that have been automatically modified by injury detection system,
 * allowing coaches to review and approve changes.
 */

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createClient } from '@/lib/supabase/server'
import { canAccessClient } from '@/lib/auth-utils'
import { logger } from '@/lib/logger'

export async function GET(request: NextRequest) {
  try {
    // Authenticate user
    const supabase = await createClient()
    const {
      data: { user },
    } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user from database
    const dbUser = await prisma.user.findUnique({
      where: { email: user.email },
    })

    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    // Only coaches can access workout modifications
    if (dbUser.role !== 'COACH') {
      return NextResponse.json(
        { error: 'Access denied. Coach role required.' },
        { status: 403 }
      )
    }

    // Get query parameters
    const { searchParams } = new URL(request.url)
    const unreviewedOnly = searchParams.get('unreviewed') === 'true'
    const clientId = searchParams.get('clientId') // Optional: filter by athlete
    const days = parseInt(searchParams.get('days') || '14') // Default: last 14 days

    // Build where clause
    const whereClause: any = {
      day: {
        week: {
          program: {
            client: {
              userId: dbUser.id, // Only show modifications for this coach's athletes
            },
          },
        },
        date: {
          gte: new Date(Date.now() - days * 24 * 60 * 60 * 1000),
        },
      },
      status: {
        in: ['CANCELLED', 'MODIFIED'],
      },
    }

    if (clientId) {
      const hasAccess = await canAccessClient(dbUser.id, clientId)
      if (!hasAccess) {
        return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
      }
      whereClause.day.week.program.clientId = clientId
    }

    // Fetch modified workouts
    const workouts = await prisma.workout.findMany({
      where: whereClause,
      include: {
        day: {
          include: {
            week: {
              include: {
                program: {
                  include: {
                    client: {
                      select: {
                        id: true,
                        name: true,
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
      orderBy: {
        updatedAt: 'desc',
      },
    })

    // Transform to modification format
    const modifications = workouts.map(workout => {
      const client = workout.day.week.program.client

      // Determine original type from coachNotes (if available)
      let originalType = 'UNKNOWN'
      if (workout.coachNotes) {
        const match = workout.coachNotes.match(/Original:\s*(\w+)/)
        if (match) {
          originalType = match[1]
        }
      }

      // Determine modification action from status and coachNotes
      let action: 'CANCEL' | 'REDUCE_INTENSITY' | 'REDUCE_VOLUME' | 'CONVERT_TO_CROSS_TRAINING'
      if (workout.status === 'CANCELLED') {
        action = 'CANCEL'
      } else if (workout.type === 'ALTERNATIVE') {
        action = 'CONVERT_TO_CROSS_TRAINING'
      } else if (workout.intensity === 'EASY') {
        action = 'REDUCE_INTENSITY'
      } else {
        action = 'REDUCE_VOLUME'
      }

      // Extract reasoning from coachNotes
      const reasoning =
        workout.coachNotes || 'Automatic modification due to injury/fatigue detection'

      // Check if this was auto-generated (look for keywords in coachNotes)
      const autoGenerated =
        workout.coachNotes?.includes('pain level') ||
        workout.coachNotes?.includes('Complete rest required') ||
        workout.coachNotes?.includes('Convert to cross-training') ||
        workout.coachNotes?.includes('50% volume reduction') ||
        false

      // Check if reviewed (for now, assume unreviewed if modified < 24h ago)
      const hoursSinceModification =
        (Date.now() - new Date(workout.updatedAt).getTime()) / (1000 * 60 * 60)
      const reviewed = hoursSinceModification > 24 // Simple heuristic

      return {
        id: workout.id,
        clientId: client.id,
        clientName: client.name,
        workoutDate: workout.day.date,
        originalType,
        currentType: workout.type,
        action,
        reasoning,
        reviewed,
        autoGenerated,
        modifiedAt: workout.updatedAt,
        status: workout.status,
      }
    })

    // Filter for unreviewed only if requested
    const filteredModifications = unreviewedOnly
      ? modifications.filter(m => !m.reviewed)
      : modifications

    // Summary statistics
    const summary = {
      total: filteredModifications.length,
      unreviewed: filteredModifications.filter(m => !m.reviewed).length,
      cancelled: filteredModifications.filter(m => m.action === 'CANCEL').length,
      reducedIntensity: filteredModifications.filter(m => m.action === 'REDUCE_INTENSITY')
        .length,
      reducedVolume: filteredModifications.filter(m => m.action === 'REDUCE_VOLUME').length,
      crossTraining: filteredModifications.filter(
        m => m.action === 'CONVERT_TO_CROSS_TRAINING'
      ).length,
      autoGenerated: filteredModifications.filter(m => m.autoGenerated).length,
    }

    return NextResponse.json({
      success: true,
      modifications: filteredModifications,
      summary,
    })
  } catch (error) {
    logger.error('Error fetching workout modifications', {}, error)
    return NextResponse.json(
      {
        error: 'Failed to fetch workout modifications',
        details:
          process.env.NODE_ENV === 'production'
            ? undefined
            : (error instanceof Error ? error.message : 'Unknown error'),
      },
      { status: 500 }
    )
  }
}
